## Jacobian short implementation
# short: cases.txt
```
6 3 16 4 3 16 3 1
10 6 16 13 7 6 16 13
7 11 0 6 6 14 5 1
9 16 3 16 5 1 7 11
13 10 16 4 9 16 10 6
13 10 10 11 13 7 10 6
5 16 16 4 0 11 6 14
6 3 10 6 9 16 3 1
```

# Jacobian short: test.cu
```
#include <stdio.h>
#include <stdlib.h>
#include <cuda.h>

/**
 * Reads elliptic curve test cases from 'cases.txt' and performs point addition
 * and point doubling using correct formulas in Jacobian coordinates.
 *
 * The test cases have the following format:
 * Px Py Qx Qy (P+Q)x (P+Q)y (P+P)x (P+P)y
 * where P and Q are points on the elliptic curve.
 */

// Elliptic Curve constants for y^2 = x^3 + ax + b over finite field F_p
const int P = 17; // Prime modulus
const int a = 2;  // Elliptic curve parameter 'a'

// Function to compute modular inverse using Extended Euclidean Algorithm
__host__ __device__ int modInverse(int a, int p) {
    int t = 0, newt = 1;
    int r = p, newr = a % p;
    while (newr != 0) {
        int quotient = r / newr;
        int temp;

        temp = t;
        t = newt;
        newt = temp - quotient * newt;

        temp = r;
        r = newr;
        newr = temp - quotient * newr;
    }
    if (r > 1) return -1; // a is not invertible
    if (t < 0) t += p;
    return t;
}

// Function to compute modulo, correctly handling negative inputs
__host__ __device__ int mod(int x, int m) {
    int r = x % m;
    return r < 0 ? r + m : r;
}

// CUDA kernel for point addition and doubling calculation using Jacobian coordinates
__global__ void jacobianPointAdditionKernel(int *X1, int *Y1, int *Z1, int *X2, int *Y2, int *Z2, int *RX, int *RY, int *RZ) {
    int tid = threadIdx.x;

    if (tid == 0) { // Point addition P + Q
        // Check if P is at infinity
        if (Z1[0] == 0) {
            // Return Q
            RX[0] = X2[0];
            RY[0] = Y2[0];
            RZ[0] = Z2[0];
            return;
        }
        // Check if Q is at infinity
        if (Z2[0] == 0) {
            // Return P
            RX[0] = X1[0];
            RY[0] = Y1[0];
            RZ[0] = Z1[0];
            return;
        }

        // Calculations
        int U1 = mod(X1[0] * mod(Z2[0] * Z2[0], P), P);
        int U2 = mod(X2[0] * mod(Z1[0] * Z1[0], P), P);
        int S1 = mod(Y1[0] * mod(Z2[0] * Z2[0] * Z2[0], P), P);
        int S2 = mod(Y2[0] * mod(Z1[0] * Z1[0] * Z1[0], P), P);

        int H = mod(U2 - U1, P);
        int r = mod(S2 - S1, P);

        if (H == 0) {
            if (r == 0) {
                // P == Q, perform doubling
                if (mod(Y1[0] * Z1[0], P) == 0) {
                    // Point at infinity
                    RX[0] = 0;
                    RY[0] = 1;
                    RZ[0] = 0;
                } else {
                    // Doubling formulas
                    int XX = mod(X1[0] * X1[0], P);
                    int YY = mod(Y1[0] * Y1[0], P);
                    int YYYY = mod(YY * YY, P);
                    int ZZ = mod(Z1[0] * Z1[0], P);
                    int S = mod(4 * X1[0] * YY, P);
                    int M = mod(3 * XX + a * mod(ZZ * ZZ, P), P);
                    int T = mod(M * M - 2 * S, P);
                    RX[0] = T;
                    RY[0] = mod(M * (S - T) - 8 * YYYY, P);
                    RZ[0] = mod(2 * Y1[0] * Z1[0], P);
                }
                return;
            } else {
                // P == -Q, result is point at infinity
                RX[0] = 0;
                RY[0] = 1;
                RZ[0] = 0;
                return;
            }
        } else {
            // P != Q, perform point addition
            int H2 = mod(H * H, P);
            int H3 = mod(H * H2, P);
            int U1H2 = mod(U1 * H2, P);
            int X3 = mod(r * r - H3 - 2 * U1H2, P);
            int Y3 = mod(r * (U1H2 - X3) - S1 * H3, P);
            int Z3 = mod(H * Z1[0] * Z2[0], P);
            RX[0] = X3;
            RY[0] = Y3;
            RZ[0] = Z3;
            return;
        }
    } else if (tid == 1) { // Point doubling P + P
        // Check if point is at infinity
        if (Z1[1] == 0 || Y1[1] == 0) {
            // Point at infinity
            RX[1] = 0;
            RY[1] = 1;
            RZ[1] = 0;
            return;
        } else {
            // Doubling formulas
            int XX = mod(X1[1] * X1[1], P);
            int YY = mod(Y1[1] * Y1[1], P);
            int YYYY = mod(YY * YY, P);
            int ZZ = mod(Z1[1] * Z1[1], P);
            int S = mod(4 * X1[1] * YY, P);
            int M = mod(3 * XX + a * mod(ZZ * ZZ, P), P);
            int T = mod(M * M - 2 * S, P);
            RX[1] = T;
            RY[1] = mod(M * (S - T) - 8 * YYYY, P);
            RZ[1] = mod(2 * Y1[1] * Z1[1], P);
            return;
        }
    }
}

void runTestCasesJacobian() {
    FILE *file = fopen("cases.txt", "r");
    if (!file) {
        fprintf(stderr, "Could not open cases.txt\n");
        exit(1);
    }

    char line[1024];
    while (fgets(line, sizeof(line), file)) {
        // Parse each line in cases.txt
        int x1, y1, x2, y2, expected_rx, expected_ry, expected_rdx, expected_rdy;
        sscanf(line, "%d %d %d %d %d %d %d %d",
               &x1, &y1, &x2, &y2, &expected_rx, &expected_ry, &expected_rdx, &expected_rdy);

        int h_X1[2] = {x1, x1};
        int h_Y1[2] = {y1, y1};
        int h_Z1[2] = {1, 1};  // Z = 1 for affine inputs
        int h_X2[2] = {x2, x2};
        int h_Y2[2] = {y2, y2};
        int h_Z2[2] = {1, 1};
        int h_RX[2] = {0};
        int h_RY[2] = {0};
        int h_RZ[2] = {0};

        int *d_X1, *d_Y1, *d_Z1, *d_X2, *d_Y2, *d_Z2, *d_RX, *d_RY, *d_RZ;

        cudaMalloc((void**)&d_X1, 2 * sizeof(int));
        cudaMalloc((void**)&d_Y1, 2 * sizeof(int));
        cudaMalloc((void**)&d_Z1, 2 * sizeof(int));
        cudaMalloc((void**)&d_X2, 2 * sizeof(int));
        cudaMalloc((void**)&d_Y2, 2 * sizeof(int));
        cudaMalloc((void**)&d_Z2, 2 * sizeof(int));
        cudaMalloc((void**)&d_RX, 2 * sizeof(int));
        cudaMalloc((void**)&d_RY, 2 * sizeof(int));
        cudaMalloc((void**)&d_RZ, 2 * sizeof(int));

        cudaMemcpy(d_X1, h_X1, 2 * sizeof(int), cudaMemcpyHostToDevice);
        cudaMemcpy(d_Y1, h_Y1, 2 * sizeof(int), cudaMemcpyHostToDevice);
        cudaMemcpy(d_Z1, h_Z1, 2 * sizeof(int), cudaMemcpyHostToDevice);
        cudaMemcpy(d_X2, h_X2, 2 * sizeof(int), cudaMemcpyHostToDevice);
        cudaMemcpy(d_Y2, h_Y2, 2 * sizeof(int), cudaMemcpyHostToDevice);
        cudaMemcpy(d_Z2, h_Z2, 2 * sizeof(int), cudaMemcpyHostToDevice);

        jacobianPointAdditionKernel<<<1, 2>>>(d_X1, d_Y1, d_Z1, d_X2, d_Y2, d_Z2, d_RX, d_RY, d_RZ);
        cudaDeviceSynchronize();

        cudaMemcpy(h_RX, d_RX, 2 * sizeof(int), cudaMemcpyDeviceToHost);
        cudaMemcpy(h_RY, d_RY, 2 * sizeof(int), cudaMemcpyDeviceToHost);
        cudaMemcpy(h_RZ, d_RZ, 2 * sizeof(int), cudaMemcpyDeviceToHost);

        // Convert back from Jacobian to affine coordinates for comparison
        int rx_affine, ry_affine;
        if (h_RZ[0] == 0) {
            rx_affine = -1; // Point at infinity
            ry_affine = -1;
        } else {
            int z_inv = modInverse(h_RZ[0], P);
            int z_inv2 = mod(z_inv * z_inv, P);
            int z_inv3 = mod(z_inv2 * z_inv, P);
            rx_affine = mod(h_RX[0] * z_inv2, P);
            ry_affine = mod(h_RY[0] * z_inv3, P);
        }

        int rdx_affine, rdy_affine;
        if (h_RZ[1] == 0) {
            rdx_affine = -1; // Point at infinity
            rdy_affine = -1;
        } else {
            int z_inv = modInverse(h_RZ[1], P);
            int z_inv2 = mod(z_inv * z_inv, P);
            int z_inv3 = mod(z_inv2 * z_inv, P);
            rdx_affine = mod(h_RX[1] * z_inv2, P);
            rdy_affine = mod(h_RY[1] * z_inv3, P);
        }

        // Test results with expected values
        int add_correct = ((rx_affine == expected_rx || (rx_affine == -1 && expected_rx == -1)) &&
                           (ry_affine == expected_ry || (ry_affine == -1 && expected_ry == -1)));

        int dbl_correct = ((rdx_affine == expected_rdx || (rdx_affine == -1 && expected_rdx == -1)) &&
                           (rdy_affine == expected_rdy || (rdy_affine == -1 && expected_rdy == -1)));

        printf("P=(%d, %d), Q=(%d, %d) -> Addition %s, Doubling %s\n",
               x1, y1, x2, y2,
               add_correct ? "PASS" : "FAIL",
               dbl_correct ? "PASS" : "FAIL");

        cudaFree(d_X1);
        cudaFree(d_Y1);
        cudaFree(d_Z1);
        cudaFree(d_X2);
        cudaFree(d_Y2);
        cudaFree(d_Z2);
        cudaFree(d_RX);
        cudaFree(d_RY);
        cudaFree(d_RZ);
    }

    fclose(file);
}

int main() {
    runTestCasesJacobian();
    return 0;
}
```

## Jacobian short output:
```
P=(6, 3), Q=(16, 4) -> Addition PASS, Doubling PASS
P=(10, 6), Q=(16, 13) -> Addition PASS, Doubling PASS
P=(7, 11), Q=(0, 6) -> Addition PASS, Doubling PASS
P=(9, 16), Q=(3, 16) -> Addition PASS, Doubling PASS
P=(13, 10), Q=(16, 4) -> Addition PASS, Doubling PASS
P=(13, 10), Q=(10, 11) -> Addition PASS, Doubling PASS
P=(5, 16), Q=(16, 4) -> Addition PASS, Doubling PASS
P=(6, 3), Q=(10, 6) -> Addition PASS, Doubling PASS
```

## Affine bignum implementation
# public_key.h
```
#ifdef BN_128
    #define CURVE_P_VALUES_MAX_SIZE 2

    __device__ __constant__ BN_ULONG CURVE_GX_values[CURVE_P_VALUES_MAX_SIZE] = {
        0x029BFCDB2DCE28D959F2815B16F81798,
        0x79BE667EF9DCBBAC55A06295CE870B07
    };

    __device__ __constant__ BN_ULONG CURVE_GY_values[CURVE_P_VALUES_MAX_SIZE] = {
        0xFD17B448A68554199C47D08FFB10D4B8,
        0x483ADA7726A3C4655DA4FBFC0E1108A8
    };

    __device__ __constant__ BIGNUM CURVE_A = {0};

    __device__ __constant__ BIGNUM CURVE_P = {
        {
            0xfffffffffffffffffffffffefffffc2f,
            0xffffffffffffffffffffffffffffffff
        },
        CURVE_P_VALUES_MAX_SIZE,
        false
    };
#else
    #define CURVE_P_VALUES_MAX_SIZE 4
    __device__ __constant__ BN_ULONG CURVE_GX_values[CURVE_P_VALUES_MAX_SIZE] = {
            0x59F2815B16F81798,
            0x029BFCDB2DCE28D9,
            0x55A06295CE870B07,
            0x79BE667EF9DCBBAC
            };
    __device__ __constant__ BN_ULONG CURVE_GY_values[CURVE_P_VALUES_MAX_SIZE] = {
            0x9C47D08FFB10D4B8,
            0xFD17B448A6855419,
            0x5DA4FBFC0E1108A8,
            0x483ADA7726A3C465
            };
    __device__ __constant__ BIGNUM CURVE_A = {0};
    __device__ __constant__ BIGNUM CURVE_P = {
        {
            0xFFFFFFFEFFFFFC2F,
            0xFFFFFFFFFFFFFFFF,
            0xFFFFFFFFFFFFFFFF,
            0xFFFFFFFFFFFFFFFF
        },
        CURVE_P_VALUES_MAX_SIZE,
        false
    };
#endif

__device__ void GetPublicKey(uint8_t* buffer, uint8_t* key)
{
    #ifdef debug_print
        printf("++ GetPublicKey ++\n");
        // print key
        printf(">> key: ");
        for (int i = 0; i < 32; i++) {
            printf("%02x", key[i]);
        }
        printf("\n");
    #endif
    BIGNUM newKey;
    init_zero(&newKey);
    #ifdef BN_128
        for (int i = 0; i < CURVE_P_VALUES_MAX_SIZE; ++i) {
            newKey.d[CURVE_P_VALUES_MAX_SIZE - 1 - i] = ((BN_ULONG)key[16*i] << 120) |
                                                        ((BN_ULONG)key[16*i + 1] << 112) |
                                                        ((BN_ULONG)key[16*i + 2] << 104) |
                                                        ((BN_ULONG)key[16*i + 3] << 96) |
                                                        ((BN_ULONG)key[16*i + 4] << 88) |
                                                        ((BN_ULONG)key[16*i + 5] << 80) |
                                                        ((BN_ULONG)key[16*i + 6] << 72) |
                                                        ((BN_ULONG)key[16*i + 7] << 64) |
                                                        ((BN_ULONG)key[16*i + 8] << 56) |
                                                        ((BN_ULONG)key[16*i + 9] << 48) |
                                                        ((BN_ULONG)key[16*i + 10] << 40) |
                                                        ((BN_ULONG)key[16*i + 11] << 32) |
                                                        ((BN_ULONG)key[16*i + 12] << 24) |
                                                        ((BN_ULONG)key[16*i + 13] << 16) |
                                                        ((BN_ULONG)key[16*i + 14] << 8) |
                                                        (BN_ULONG)key[16*i + 15];
        }
    #else
        for (int i = 0; i < CURVE_P_VALUES_MAX_SIZE; ++i) {
            newKey.d[3 - i] = ((BN_ULONG)key[8*i] << 56) | 
                                ((BN_ULONG)key[8*i + 1] << 48) | 
                                ((BN_ULONG)key[8*i + 2] << 40) | 
                                ((BN_ULONG)key[8*i + 3] << 32) |
                                ((BN_ULONG)key[8*i + 4] << 24) | 
                                ((BN_ULONG)key[8*i + 5] << 16) | 
                                ((BN_ULONG)key[8*i + 6] << 8) | 
                                ((BN_ULONG)key[8*i + 7]);
        }
    #endif
    newKey.top = CURVE_P_VALUES_MAX_SIZE;

    #ifdef debug_print
        // Print newKey
        bn_print("[#] newKey: ", &newKey);
    #endif

    // Initialize generator
    EC_POINT_CUDA G;
    init_zero(&G.x);
    init_zero(&G.y);
    // for (int j = 0; j < MAX_BIGNUM_SIZE; ++j) {
    for (int j = 0; j < CURVE_P_VALUES_MAX_SIZE; ++j) {
            G.x.d[j] = CURVE_GX_values[j];
            G.y.d[j] = CURVE_GY_values[j];
        }
    G.x.top = CURVE_P_VALUES_MAX_SIZE;
    G.y.top = CURVE_P_VALUES_MAX_SIZE;
    #ifdef debug_top
        if (G.x.top != find_top(&G.x)) printf("### ERROR: GetPublicKey: G.x.top (%d) != find_top(&G.x) (%d)\n", G.x.top, find_top(&G.x));
        if (G.y.top != find_top(&G.y)) printf("### ERROR: GetPublicKey: G.y.top (%d) != find_top(&G.y) (%d)\n", G.y.top, find_top(&G.y));
    #endif

    // TODO: Check do we need to define extra G. Or we are able to use __constant__ CURVE_GX_values and CURVE_GY_values as new EC_POINT_CUDA instead
    EC_POINT_CUDA publicKey = ec_point_scalar_mul(&G, &newKey, &CURVE_P, &CURVE_A); // FAIL with index 0. CHECK newKey.
    #ifdef debug_print
        // Print the public key
        bn_print("[*] publicKey.x: ", &publicKey.x);
        bn_print("[*] publicKey.y: ", &publicKey.y);
    #endif

    
    // Copy the public key to buffer
    #ifdef BN_128
        // Copy the public key to buffer for 128-bit
        for (int i = 0; i < CURVE_P_VALUES_MAX_SIZE; i++) {
            BN_ULONG word = publicKey.x.d[CURVE_P_VALUES_MAX_SIZE - 1 - i];
            for (int j = 0; j < 16; j++) {
                buffer[16*i + j] = (word >> (120 - 8*j)) & 0xFF;
            }
        }
    #else
        for (int i = 0; i < CURVE_P_VALUES_MAX_SIZE; i++) {
            buffer[8*i] = (publicKey.x.d[3 - i] >> 56) & 0xFF;
            buffer[8*i + 1] = (publicKey.x.d[3 - i] >> 48) & 0xFF;
            buffer[8*i + 2] = (publicKey.x.d[3 - i] >> 40) & 0xFF;
            buffer[8*i + 3] = (publicKey.x.d[3 - i] >> 32) & 0xFF;
            buffer[8*i + 4] = (publicKey.x.d[3 - i] >> 24) & 0xFF;
            buffer[8*i + 5] = (publicKey.x.d[3 - i] >> 16) & 0xFF;
            buffer[8*i + 6] = (publicKey.x.d[3 - i] >> 8) & 0xFF;
            buffer[8*i + 7] = publicKey.x.d[3 - i] & 0xFF;
        }
    #endif
    // Shift the buffer by 1 byte
    for (int i = 33; i > 0; i--) {
        buffer[i] = buffer[i - 1];
    }
    
    // Determine the prefix based on the Y coordinate
    BIGNUM two, quotient, remainder;
    init_zero(&two);
    init_zero(&quotient);
    init_zero(&remainder);
    // Set two to 2
    bn_set_word(&two, 2);
    bn_div(&quotient, &remainder, &publicKey.y, &two);
    uint8_t prefix = bn_is_zero(&remainder) ? 0x02 : 0x03;
    
    // Alternate solution of copying the public key to buffer
    // Is not so clear as the previous one but works for both 64-bit and 128-bit
    // // Copy the public key to buffer
    // size_t limb_size_bytes = sizeof(BN_ULONG);
    // for (int i = 0; i < CURVE_P_VALUES_MAX_SIZE; i++) {
    //     BN_ULONG limb = publicKey.x.d[CURVE_P_VALUES_MAX_SIZE - 1 - i];
    //     for (int j = 0; j < limb_size_bytes; j++) {
    //         buffer[limb_size_bytes * i + j + 1] = (limb >> (8 * (limb_size_bytes - 1 - j))) & 0xFF;
    //     }
    // }
    
    // Add prefix before the buffer
    buffer[0] = prefix;
    #ifdef debug_print
        // Print the public key
        printf(">> buffer: ");
        for (int i = 0; i < 33; i++) {
            printf("%02x", buffer[i]);
        }
        printf("\n-- GetPublicKey --\n");
    #endif
}
```

# function_profiling.h
```
#include <fstream>
#include <iostream>

#ifndef FUNCTION_PROFILING_H
#define FUNCTION_PROFILING_H

#define NUM_FUNCTIONS 7

typedef enum {
    FN_BN_MUL,
    FN_BN_MUL_FROM_DIV,
    FN_BN_ADD,
    FN_BN_SUB,
    FN_BN_SUB_FROM_DIV,
    FN_BN_DIV,
    FN_MAIN,
    FN_COUNT // Should be equal to NUM_FUNCTIONS
} FunctionIndex;

typedef struct {
    unsigned int function_calls[NUM_FUNCTIONS];
    unsigned long long function_times[NUM_FUNCTIONS];
} ThreadFunctionProfile;

#ifdef __CUDACC__
__device__ ThreadFunctionProfile *d_threadFunctionProfiles;
#else
extern __device__ ThreadFunctionProfile *d_threadFunctionProfiles;
#endif

#endif // FUNCTION_PROFILING_H

__device__ void record_function(FunctionIndex fn, unsigned long long start_time) {
    unsigned long long end_time = clock64();
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    ThreadFunctionProfile *threadProfile = &d_threadFunctionProfiles[idx];
    threadProfile->function_calls[fn]++;
    threadProfile->function_times[fn] += (end_time - start_time);
}

void write_function_profile_to_csv(const char* filename, ThreadFunctionProfile* profiles, int totalThreads, int threadsPerBlock) {
    const char* function_names_host[NUM_FUNCTIONS] = {
        "bn_mul",
        "bn_mul_from_div",
        "bn_add",
        "bn_sub",
        "bn_sub_from_div",
        "bn_div",
        "main"
    };
    
    std::ofstream file(filename);
    if (!file.is_open()) {
        std::cerr << "Error opening file: " << filename << std::endl;
        return;
    }

    file << "BlockIdx,ThreadIdx,FunctionName,Calls,TotalTime(cycles)\n";

    for (int idx = 0; idx < totalThreads; idx++) {
        int blockIdx = idx / threadsPerBlock;
        int threadIdx = idx % threadsPerBlock;
        ThreadFunctionProfile &profile = profiles[idx];

        for (int fn = 0; fn < NUM_FUNCTIONS; fn++) {
            const char* functionName = function_names_host[fn];
            unsigned int calls = profile.function_calls[fn];
            unsigned long long totalTime = profile.function_times[fn];

            if (calls > 0) {
                file << blockIdx << "," << threadIdx << "," << functionName << "," << calls << "," << totalTime << "\n";
            }
        }
    }

    file.close();
    // std::cout << "Function profiling data saved to " << filename << std::endl;
}
```

# bignum.h
```
#include <limits.h>
#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include "function_profiling.h"

// #define BN_128
// #define debug_print
// #define debug_bn_copy
// #define debug_top
// #define function_profiler

#ifdef BN_128
    #define BN_ULONG unsigned __int128
    #define uint128_t unsigned __int128
    #define BN_ULONG_MAX ((BN_ULONG)-1)
    #define MAX_BIGNUM_SIZE 5     // Reduced from 10 to 5 due to __int128
#else
    #define BN_ULONG unsigned long long
    #define BN_ULONG_MAX ((BN_ULONG)-1)
    #define MAX_BIGNUM_SIZE 10
#endif

#define MAX_BIT_ARRAY_SIZE 256 // Limit to 256 bits to match the function's design
#define BN_ULONG_NUM_BITS (sizeof(BN_ULONG) * 8)
#define PUBLIC_KEY_SIZE 33  // Assuming a 33-byte public key (compressed format)
#define DEVICE_CLOCK_RATE 1708500

typedef struct bignum_st {
    BN_ULONG d[MAX_BIGNUM_SIZE];
    unsigned char top;
    bool neg;
} BIGNUM;

// Initialize BIGNUM to zero
#ifdef BN_128
    __device__ const BIGNUM ZERO_BIGNUM = {
        {0},                  // d (will be properly initialized in init_zero)
        1,                    // top (unsigned char)
        0                    // neg (bool)
    };
#else
    __device__ const BIGNUM ZERO_BIGNUM = {
        {0},                  // d (will be properly initialized in init_zero)
        1,                    // top (unsigned char)
        0                    // neg (bool)
    };
#endif

__device__ void init_zero(BIGNUM *bn) {
    *bn = ZERO_BIGNUM;
}
__device__ void init_one(BIGNUM *bn) {
    // Initialize the BIGNUM to zero
    *bn = ZERO_BIGNUM;
    
    // Set the least significant word to 1
    bn->d[0] = 1;
    
    // Set the top to 1 (as there is one significant digit)
    bn->top = 1;
}

// __device__ bool bn_add(BIGNUM *result, BIGNUM *a, BIGNUM *b);
__device__ bool bn_add(BIGNUM *result, const BIGNUM *a, const BIGNUM *b);
// __device__ int bn_mod(BIGNUM *r, BIGNUM *m, BIGNUM *d);
__device__ int bn_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *n);
__device__ bool bn_is_zero(const BIGNUM *a);

__device__ unsigned char find_top(const BIGNUM *bn) {
    for (int i = MAX_BIGNUM_SIZE - 1; i >= 0; i--) {
        if (bn->d[i] != 0) {
            return i + 1;
        }
    }
    return 1;
}

__device__ unsigned char find_top_optimized(const BIGNUM *bn, const char start_index) {
    const char start = start_index > MAX_BIGNUM_SIZE ? MAX_BIGNUM_SIZE : start_index;
    for (char i = start - 1; i >= 0; i--) {
        if (bn->d[i] != 0) {
            return i + 1;
        }
    }
    return 1;
}

__device__ void bn_print(const char* msg, const BIGNUM* a) {
    // if (!debug_print) return;
    #ifndef debug_print
        return;
    #endif
    
    #ifdef debug_top
        if (a->top != find_top(a)) printf("### ERROR: bn_print: a->top (%d) != find_top(a) (%d)\n", a->top, find_top(a));
    #endif
    printf("%s", msg);
    printf("[");
    if (a->neg) printf("-");
    else printf("+");
    printf("%d] ", a->top);
    if (a->neg) {
        printf("-");  // Handle the case where BIGNUM is negative
    }
    // for (int i = MAX_BIGNUM_SIZE - 1; i >= 0; i--) {
    for (int i = a->top - 1; i >= 0; i--) {
        // Print words up to top - 1 with appropriate formatting
        // if (i == MAX_BIGNUM_SIZE - 1) {
        if (i == a->top - 1) {
            #ifdef BN_128
                printf("%016llx%016llx", (unsigned long long)(a->d[i] >> 64), (unsigned long long)(a->d[i] & 0xFFFFFFFFFFFFFFFFULL));
            #else
                printf("%llx", a->d[i]);
            #endif
        } else {
            #ifdef BN_128
                printf("%016llx%016llx", (unsigned long long)(a->d[i] >> 64), (unsigned long long)(a->d[i] & 0xFFFFFFFFFFFFFFFFULL));
            #else
                printf("%016llx", a->d[i]);
            #endif
        }
        // return;
    }
    printf("\n");
}

__device__ void bn_print_no_fuse(const char* msg, const BIGNUM* a) {   
    #ifdef debug_top
        if (a->top != find_top(a)) printf("### ERROR: bn_print: a->top (%d) != find_top(a) (%d)\n", a->top, find_top(a));
    #endif
    printf("%s", msg);
    printf("[");
    if (a->neg) printf("-");
    else printf("+");
    printf("%d] ", a->top);
    if (a->neg) {
        printf("-");  // Handle the case where BIGNUM is negative
    }
    // for (int i = MAX_BIGNUM_SIZE - 1; i >= 0; i--) {
    for (int i = a->top - 1; i >= 0; i--) {
        // Print words up to top - 1 with appropriate formatting
        // if (i == MAX_BIGNUM_SIZE - 1) {
        if (i == a->top - 1) {
            #ifdef BN_128
                printf("%016llx%016llx", (unsigned long long)(a->d[i] >> 64), (unsigned long long)(a->d[i] & 0xFFFFFFFFFFFFFFFFULL));
            #else
                printf("%llx", a->d[i]);
            #endif
        } else {
            #ifdef BN_128
                printf("%016llx%016llx", (unsigned long long)(a->d[i] >> 64), (unsigned long long)(a->d[i] & 0xFFFFFFFFFFFFFFFFULL));
            #else
                printf("%016llx", a->d[i]);
            #endif
        }
        // return;
    }
    printf("\n");
}

__device__ void print_as_hex(const uint8_t *data, const uint32_t len) {
    for (uint32_t i = 0; i < len; i++) {
        printf("%02x", data[i]);
    }
    printf("\n");
}

__device__ void debug_printf(const char *fmt, ...) {
    // if (debug_print) {
    #ifdef debug_print
        printf(fmt);
    #endif
    // }
}

__device__ int bn_cmp(const BIGNUM* a, const BIGNUM* b) {
    // -1: a < b
    // 0: a == b
    // 1: a > b
    #ifdef debug_print
        // printf("++ bn_cmp ++\n");
        // bn_print(">> a: ", a);
        // bn_print(">> b: ", b);
    #endif
    if (a->neg != b->neg) {
        #ifdef debug_print
            // printf("a->neg != b->neg\n-- bn_cmp --\n");
        #endif
        return a->neg ? -1 : 1;
    }
    #ifdef debug_top
        if (a->top != find_top(a)) printf("### ERROR: bn_cmp: a->top != find_top(a)\n");
        if (b->top != find_top(b)) printf("### ERROR: bn_cmp: b->top != find_top(b)\n");
    #endif
    if (a->top != b->top) {
        #ifdef debug_print
            // printf("a->top != b->top\n-- bn_cmp --\n");
        #endif
        return a->top > b->top ? 1 : -1;
    }

    for (int i = a->top - 1; i >= 0; i--) {
        if (a->d[i] != b->d[i]) {
            #ifdef debug_print
                // printf("a->d[i] != b->d[i]\n-- bn_cmp --\n");
            #endif
            return a->d[i] > b->d[i] ? 1 : -1;
        }
    }
    #ifdef debug_print
        // printf("default case\n-- bn_cmp --\n");
    #endif
    return 0;
}

__device__ int bn_cmp_abs(const BIGNUM *a, const BIGNUM *b) {
    if (a->top > b->top)
        return 1;
    if (b->top > a->top)
        return -1;

    for (int i = a->top - 1; i >= 0; i--) {
        if (a->d[i] > b->d[i])
            return 1;
        if (b->d[i] > a->d[i])
            return -1;
    }
    return 0;
}

// Helper function to perform a deep copy of BIGNUM
__device__ void bn_copy(BIGNUM *dest, const BIGNUM *src) {
    #ifdef debug_print
        // printf("++ bn_copy ++\n");
        // bn_print(">> src: ", src);
        // bn_print(">> dest: ", dest);
    #endif
    // Init dst as zero
    init_zero(dest);

    if (dest == nullptr || src == nullptr) {
        return;
    }
    #ifdef debug_top
        if (src->top != find_top(src)) printf("### ERROR: bn_copy: src->top (%d) != find_top(src) (%d)\n", src->top, find_top(src));
        if (src->top > MAX_BIGNUM_SIZE) {
            printf("### bn_copy ERROR: src->top > MAX_BIGNUM_SIZE\n");
        }
    #endif

    // Copy the neg and top fields
    dest->neg = src->neg;
    dest->top = src->top;

    int i;

    // Copy the array of BN_ULONG digits.
    for (i = 0; i < src->top; i++) {
        dest->d[i] = src->d[i];
    }

    // Set the rest of the words in dest to 0 if dest's top is larger
    for (i = src->top; i < MAX_BIGNUM_SIZE; i++) {
        dest->d[i] = 0;
    }
    #ifdef debug_print
        // bn_print("<< dest: ", dest);
        // printf("-- bn_copy --\n");
    #endif
}

#ifdef BN_128
    __device__ void absolute_add(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {
        unsigned char max_top = max(a->top, b->top);
        volatile BN_ULONG carry = 0;

        for (int i = 0; i <= max_top; ++i) {
            volatile BN_ULONG ai = (i < a->top) ? a->d[i] : 0;
            volatile BN_ULONG bi = (i < b->top) ? b->d[i] : 0;
            volatile BN_ULONG sum;

            uint64_t ai_lo = (uint64_t)ai;
            uint64_t ai_hi = (uint64_t)(ai >> 64);
            uint64_t bi_lo = (uint64_t)bi;
            uint64_t bi_hi = (uint64_t)(bi >> 64);

            uint64_t sum_lo = ai_lo + bi_lo + (uint64_t)carry;
            uint64_t carry_lo = (sum_lo < ai_lo) || (carry && sum_lo == ai_lo);

            uint64_t sum_hi = ai_hi + bi_hi + carry_lo;
            carry = (sum_hi < ai_hi) || (carry_lo && sum_hi == ai_hi) ? 1 : 0;

            sum = ((BN_ULONG)sum_hi << 64) | sum_lo;
            result->d[i] = sum;
            __threadfence();  // Ensure global visibility of each word
        }

        if (carry > 0 && max_top < MAX_BIGNUM_SIZE - 1) {
            result->d[max_top + 1] = carry;
            max_top++;
        }

        // result->top = max_top + 1;
        result->top = find_top_optimized(result, max_top+1);
        __threadfence();  // Final memory barrier
    }
#else
    __device__ void absolute_add(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {
        // if (a->top != find_top(a)) printf("err: absolute_add: a->top != find_top(a)\n"); // no errors has been found
        // if (b->top != find_top(b)) printf("err: absolute_add: b->top != find_top(b)\n");
        // Determine the maximum size to iterate over
        unsigned char max_top = max(a->top, b->top);
        BN_ULONG carry = 0;

        unsigned char i;

        // Initialize result
        for (i = 0; i <= max_top; ++i) {
            result->d[i] = 0;
        }
        result->top = max_top;

        for (i = 0; i <= max_top; ++i) {
            // Extract current words or zero if one bignum is shorter
            BN_ULONG ai = (i < a->top) ? a->d[i] : 0;
            BN_ULONG bi = (i < b->top) ? b->d[i] : 0;
            
            // Calculate sum and carry
            BN_ULONG sum = ai + bi + carry;

            // Store result
            result->d[i] = sum; // No need for masking as BN_ULONG is already the correct size

            // Calculate carry
            carry = (sum < ai) || (carry > 0 && sum == ai) ? 1 : 0;
        }

        // Handle carry out, expand result if necessary
        if (carry > 0) {
            if (result->top < MAX_BIGNUM_SIZE - 1) {
                result->d[result->top] = carry;
                result->top++;
            } else {
                // Handle error: Result BIGNUM doesn't have space for an additional word.
                // This should potentially be reported back to the caller.
                printf("absolute_add: Result BIGNUM doesn't have space for an additional word.\n");
            }
        }
        result->top = find_top_optimized(result, max_top+1);
    }
#endif

__device__ void absolute_subtract(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {

    unsigned char max_top = max(a->top, b->top);
    BN_ULONG borrow = 0;
    result->top = max_top;

    for (unsigned char i = 0; i < max_top; ++i) {
        BN_ULONG ai = (i < a->top) ? a->d[i] : 0;
        BN_ULONG bi = (i < b->top) ? b->d[i] : 0;

        // Perform subtraction
        BN_ULONG diff = ai - bi - borrow;
        
        // Check if borrow occurred
        if (ai < bi || (borrow && ai == bi)) {
            borrow = 1;
        } else {
            borrow = 0;
        }

        result->d[i] = diff;
    }

    // // Normalize the result (remove leading zeros)
    // while (result->top > 0 && result->d[result->top - 1] == 0) {
    //     result->top--;
    // }

    // // If the result is zero, ensure top is set to 1 and d[0] is 0
    // if (result->top == 0) {
    //     result->top = 1;
    //     result->d[0] = 0;
    // }
    result->top = find_top_optimized(result, max_top);
}

__device__ bool bn_sub(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    // If one is negative and the other is positive, it's essentially an addition.
    if (a->neg != b->neg) {
        result->neg = a->neg; // The sign will be the same as the sign of 'a'.
        absolute_add(result, a, b); // Perform the addition of magnitudes here because signs are different.
        #ifdef function_profiler
            record_function(FN_BN_SUB, start_time);
        #endif
        return true;
    }

    // Compare the absolute values to decide the order of subtraction and sign of the result.
    int cmp_res = bn_cmp_abs(a, b); // This function should compare the absolute values of 'a' and 'b'.
    
    if (cmp_res >= 0) {
        // |a| >= |b|, perform a - b, result takes sign from 'a'.
        result->neg = a->neg;
        absolute_subtract(result, a, b);
    } else {
        // |b| > |a|, perform b - a instead, result takes opposite sign from 'a'.
        result->neg = !a->neg;
        absolute_subtract(result, b, a);
    }

    // Perform additional logic if underflow has been detected in absolute_subtract.
    if (result->top == 0) { 
        // Handle underflow if needed. 
    }
    #ifdef function_profiler
        record_function(FN_BN_SUB, start_time);
    #endif
    return true;
}

__device__ bool bn_sub_from_div(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    // If one is negative and the other is positive, it's essentially an addition.
    if (a->neg != b->neg) {
        result->neg = a->neg; // The sign will be the same as the sign of 'a'.
        absolute_add(result, a, b); // Perform the addition of magnitudes here because signs are different.
        #ifdef function_profiler
            record_function(FN_BN_SUB_FROM_DIV, start_time);
        #endif
        return true;
    }

    // Compare the absolute values to decide the order of subtraction and sign of the result.
    int cmp_res = bn_cmp_abs(a, b); // This function should compare the absolute values of 'a' and 'b'.
    
    if (cmp_res >= 0) {
        // |a| >= |b|, perform a - b, result takes sign from 'a'.
        result->neg = a->neg;
        absolute_subtract(result, a, b);
    } else {
        // |b| > |a|, perform b - a instead, result takes opposite sign from 'a'.
        result->neg = !a->neg;
        absolute_subtract(result, b, a);
    }

    // Perform additional logic if underflow has been detected in absolute_subtract.
    if (result->top == 0) { 
        // Handle underflow if needed. 
    }
    #ifdef function_profiler
        record_function(FN_BN_SUB_FROM_DIV, start_time);
    #endif
    return true;
}

__device__ int absolute_compare(const BIGNUM* a, const BIGNUM* b) {
    // absolute_compare logic:
    //  1 when |a| is larger
    // -1 when |b| is larger
    //  0 when |a| and |b| are equal in absolute value

    // Skip leading zeros and find the actual top for a
    int a_top = a->top - 1;
    while (a_top >= 0 && a->d[a_top] == 0) a_top--;

    // Skip leading zeros and find the actual top for b
    int b_top = b->top - 1;
    while (b_top >= 0 && b->d[b_top] == 0) b_top--;

    // Compare actual tops
    if (a_top > b_top) return 1; // |a| is larger
    if (a_top < b_top) return -1; // |b| is larger

    // Both numbers have the same number of significant digits, compare digit by digit
    for (int i = a_top; i >= 0; i--) {
        if (a->d[i] > b->d[i]) return 1; // |a| is larger
        if (a->d[i] < b->d[i]) return -1; // |b| is larger
    }
    return 0; // |a| and |b| are equal in absolute value
}

__device__ bool bn_add(BIGNUM *result, const BIGNUM *a, const BIGNUM *b) {
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    #ifdef debug_print
        printf("++ bn_add ++\n");
        bn_print(">> a: ", a);
        // printf(">> a->top: %d\n", a->top);
        // printf(">> a->neg: %d\n", a->neg);
        bn_print(">> b: ", b);
        // printf(">> b->top: %d\n", b->top);
        // printf(">> b->neg: %d\n", b->neg);
        // bn_print(">> result: ", result);
    #endif
    init_zero(result);
    unsigned char max_top = max(a->top, b->top);

    if (a->neg == b->neg) {
        // Both numbers have the same sign, so we can directly add them.
        absolute_add(result, a, b);
        // bn_print("absolute_add >> result: ", result); // <<== printing this result DOES NOT leads to correct answer
        result->neg = a->neg; // The sign will be the same as both operands.
    } else {
        // The numbers have different signs, so we need to compare their absolute values to decide on the operation.
        int cmp_result = absolute_compare(a, b);
        if (cmp_result < 0) {
            // |b| is greater than |a|, so we'll do b - a and assign the sign of b to the result.
            absolute_subtract(result, b, a);
            result->neg = b->neg;
        } else if (cmp_result > 0) {
            // |a| is greater than |b|, so we'll do a - b and assign the sign of a to the result.
            absolute_subtract(result, a, b);
            result->neg = a->neg;
        } else {
            // |a| is equal to |b|, so the result is 0.
            // The result of adding two numbers with different signs but equal magnitude is 0.
            result->neg = 0; // Set sign to 0 for non-negative.
            result->top = 1; // The result is 0, so top is 1 to denote one valid word which is zero.
            result->d[0] = 0;
        }
    }
    // result->top = find_top_optimized(result, max_top + 1);
    #ifdef debug_print
        printf(">> result: ");
        bn_print("", result);
        printf("-- bn_add --\n");
    #endif
    #ifdef function_profiler
        record_function(FN_BN_ADD, start_time);
    #endif
    return true;
}

__device__ int bn_div(BIGNUM *a, BIGNUM *b, const BIGNUM *q, const BIGNUM *r);
__device__ void bn_mul(const BIGNUM *a, const BIGNUM *b, BIGNUM *product);

__device__ void set_bn(BIGNUM *dest, const BIGNUM *src) {
    // debug_printf("set_bn 0\n");
    // update src->top
    // src->top = find_top(src);
    #ifdef debug_top
        if (src->top != find_top(src)) printf("### ERROR: set_bn: src->top != find_top(src)\n");
    #endif
    // Check if dest has enough space to copy from src
    if (MAX_BIGNUM_SIZE < src->top) {    
        // Handle the situation appropriately
        // Depending on how memory is managed, this could be an error or resize operation
        return;
    }

    // Copy over the significant words from source to destination.
    for (int i = 0; i < src->top; ++i) {
        debug_printf("set_bn 1.%d\n", i);
        dest->d[i] = src->d[i];
    }

    // Zero out any remaining entries in the array if the source 'top' is less than the dest 'dmax'
    for (int i = src->top; i < MAX_BIGNUM_SIZE; ++i) {
        debug_printf("set_bn 2.%d\n", i);
        dest->d[i] = 0;
    }

    debug_printf("set_bn 3\n");

    // Set the 'top' and 'neg' flags after zeroing
    dest->top = src->top;
    dest->neg = src->neg;
}

__device__ void mul64x64(uint64_t a, uint64_t b, uint64_t *hi, uint64_t *lo) {
    uint64_t a_low = (uint32_t)a;
    uint64_t a_high = a >> 32;
    uint64_t b_low = (uint32_t)b;
    uint64_t b_high = b >> 32;

    uint64_t res_low = a_low * b_low;
    uint64_t res_mid1 = a_low * b_high;
    uint64_t res_mid2 = a_high * b_low;
    uint64_t res_high = a_high * b_high;

    uint64_t carry = (res_low >> 32) + (uint32_t)res_mid1 + (uint32_t)res_mid2;
    uint64_t mid_high = (res_mid1 >> 32) + (res_mid2 >> 32) + (carry >> 32);

    *lo = (res_low & 0xFFFFFFFFULL) | ((carry & 0xFFFFFFFFULL) << 32);
    *hi = res_high + mid_high;
}

__device__ void bn_mul_64_ok(const BIGNUM *a, const BIGNUM *b, BIGNUM *product) {
    // Initialize product
    init_zero(product);

    #ifdef BN_128
        // Convert 128-bit BN_ULONGs to arrays of 64-bit words
        const int a_words = a->top * 2; // Since each BN_ULONG is 128 bits
        const int b_words = b->top * 2;
        uint64_t a_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t b_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t result_array[MAX_BIGNUM_SIZE * 4] = {0};

        // Expand 'a' into 'a_array'
        for (int i = 0; i < a->top; ++i) {
            a_array[2 * i] = (uint64_t)(a->d[i] & 0xFFFFFFFFFFFFFFFFULL); // Lower 64 bits
            a_array[2 * i + 1] = (uint64_t)(a->d[i] >> 64);               // Upper 64 bits
        }

        // Expand 'b' into 'b_array'
        for (int i = 0; i < b->top; ++i) {
            b_array[2 * i] = (uint64_t)(b->d[i] & 0xFFFFFFFFFFFFFFFFULL); // Lower 64 bits
            b_array[2 * i + 1] = (uint64_t)(b->d[i] >> 64);               // Upper 64 bits
        }

        // Perform multiplication using 64-bit arithmetic
        for (int i = 0; i < a_words; ++i) {
            uint64_t ai = a_array[i];
            uint64_t carry = 0;
            for (int j = 0; j < b_words; ++j) {
                uint64_t bj = b_array[j];
                uint64_t hi, lo;
                mul64x64(ai, bj, &hi, &lo);

                // Add lo to result_array[i + j] with carry
                uint64_t sum = result_array[i + j];
                uint64_t carry_out = 0;

                sum += lo;
                if (sum < lo) carry_out += 1;

                sum += carry;
                if (sum < carry) carry_out += 1;

                result_array[i + j] = sum;

                carry = hi + carry_out;
            }
            // Add remaining carry
            result_array[i + b_words] += carry;
        }

        // Convert result_array back to 128-bit BN_ULONGs
        int product_words = a_words + b_words;
        int product_top = (product_words + 1) / 2; // Ceiling division

        for (int i = 0; i < product_top; ++i) {
            uint64_t lo = result_array[2 * i];
            uint64_t hi = (2 * i + 1 < product_words) ? result_array[2 * i + 1] : 0;
            product->d[i] = ((BN_ULONG)hi << 64) | lo;
        }

        // Update 'top' and 'neg' fields
        product->top = find_top_optimized(product, product_top);
        product->neg = a->neg ^ b->neg;
    #else
        // Existing BN_64 implementation remains unchanged
    #endif

    // Optionally print the product
    bn_print("<< product: ", product);
}

__device__ int bn_bit_length(const BIGNUM *a) {
    if (a->top == 0) return 0;
    
    int bit_length = (a->top - 1) * BN_ULONG_NUM_BITS;
    BN_ULONG top_word = a->d[a->top - 1];
    
    while (top_word) {
        top_word >>= 1;
        bit_length++;
    }
    
    return bit_length;
}

__device__ void bn_mul(const BIGNUM *a, const BIGNUM *b, BIGNUM *product) {
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    #ifdef debug_print
        printf("++ bn_mul ++\n");
        printf("BN_ULONG_NUM_BITS: %d\n", BN_ULONG_NUM_BITS);
        bn_print(">> a: ", a);
        bn_print(">> b: ", b);
    #endif
    init_zero(product);
    #ifdef BN_128
        // Not efficient for my case
        // if (a->top == 1 and b->top == 1) {
        //     int a_bit_len = bn_bit_length(a);
        //     int b_bit_len = bn_bit_length(b);
        //     int product_bit_len = a_bit_len + b_bit_len;
        //     if (product_bit_len <= BN_ULONG_NUM_BITS) {
        //         // The product can fit in a single word
        //         product->d[0] = a->d[0] * b->d[0];
        //         product->top = 1;
        //         product->neg = a->neg ^ b->neg;
        //         record_function(FN_BN_MUL, start_time);
        //         return;
        //     }
        // }
        // Multiply the numbers treating them as arrays of 64-bit words
        const unsigned char a_words = a->top * 2; // Since each BN_ULONG is 128 bits (2 * 64 bits)
        const unsigned char b_words = b->top * 2;
        uint64_t a_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t b_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t result_array[MAX_BIGNUM_SIZE * 4] = {0};

        // Expand a into a_array
        for (unsigned char i = 0; i < a->top; ++i) {
            a_array[i * 2] = (uint64_t)(a->d[i]);
            a_array[i * 2 + 1] = (uint64_t)(a->d[i] >> 64);
        }

        // Expand b into b_array
        for (unsigned char i = 0; i < b->top; ++i) {
            b_array[i * 2] = (uint64_t)(b->d[i]);
            b_array[i * 2 + 1] = (uint64_t)(b->d[i] >> 64);
        }
        // char i = (char)max(a->top, b->top);
        // while (i > 0) {
        //     --i;
        //     if (i < a->top) {
        //         a_array[i * 2] = (uint64_t)(a->d[i]);
        //         a_array[i * 2 + 1] = (uint64_t)(a->d[i] >> 64);
        //     }
        //     if (i < b->top) {
        //         b_array[i * 2] = (uint64_t)(b->d[i]);
        //         b_array[i * 2 + 1] = (uint64_t)(b->d[i] >> 64);
        //     }
        // }

        unsigned __int128 temp;
        uint64_t carry;
        // Multiply the arrays
        for (unsigned char i = 0; i < a_words; ++i) {
            carry = 0;
            for (unsigned char j = 0; j < b_words; ++j) {
                // unsigned __int128 temp = (unsigned __int128)a_array[i] * b_array[j] + result_array[i + j] + carry;
                temp = (unsigned __int128)a_array[i] * b_array[j];
                temp += result_array[i + j];
                temp += carry;
                result_array[i + j] = (uint64_t)temp;
                carry = (uint64_t)(temp >> 64);
            }
            result_array[i + b_words] += carry;
        }

        // Convert result_array back into product->d
        unsigned char product_words = a_words + b_words;
        unsigned char product_top = (product_words + 1) / 2;
        for (unsigned char i = 0; i < product_top; ++i) {
            uint64_t lo = result_array[i * 2];
            uint64_t hi = result_array[i * 2 + 1];
            product->d[i] = ((unsigned __int128)hi << 64) | lo;
        }
        product->top = find_top_optimized(product, product_top);
        #ifdef debug_top
            if (product->top > MAX_BIGNUM_SIZE) {
                printf("### bn_mul ERROR: product->top > MAX_BIGNUM_SIZE\n");
            }
        #endif
    #else
        // Unroll loops if possible
        for (int i = 0; i < a->top; i++) {
            BN_ULONG carry = 0;
            for (int j = 0; j < b->top; j++) {
                unsigned __int128 temp = (unsigned __int128)a->d[i] * b->d[j] + product->d[i + j] + carry;
                product->d[i + j] = (BN_ULONG)temp;
                carry = (BN_ULONG)(temp >> 64);
            }
            product->d[i + b->top] = carry;
        }
        // Update the top
        product->top = a->top + b->top;
        while (product->top > 1 && product->d[product->top - 1] == 0) {
            product->top--;
        }
    #endif
    // Set the sign
    product->neg = a->neg ^ b->neg;
    #ifdef debug_print
        bn_print("<< product: ", product);
        printf("-- bn_mul --\n");
    #endif
    #ifdef function_profiler
        record_function(FN_BN_MUL, start_time);
    #endif
}

__device__ void bn_mul_from_div(const BIGNUM *a, const BIGNUM *b, BIGNUM *product, const bool absolute) {
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    #ifdef debug_print
        printf("++ bn_mul ++\n");
        printf("BN_ULONG_NUM_BITS: %d\n", BN_ULONG_NUM_BITS);
        bn_print(">> a: ", a);
        bn_print(">> b: ", b);
    #endif
    // bn_print_no_fuse(">> a: ", a);
    // bn_print_no_fuse(">> b: ", b);
    init_zero(product);
    #ifdef BN_128
        // Not efficient for my case
        if (a->top == 1 && b->top == 1) {
            // printf("a->top & b->top are 1\n");
            int a_bit_len = bn_bit_length(a);
            int b_bit_len = bn_bit_length(b);
            int product_bit_len = a_bit_len + b_bit_len;
            if (product_bit_len <= BN_ULONG_NUM_BITS) {
                // The product can fit in a single word
                product->d[0] = (BN_ULONG)a->d[0] * b->d[0];
                product->top = 1;
                if (!absolute) product->neg = a->neg ^ b->neg;
                // printf("[%d x %d] ", a_bit_len, b_bit_len);
                // bn_print_no_fuse("<< product: ", product);
                record_function(FN_BN_MUL_FROM_DIV, start_time);
                return;
            }
        }
        // Multiply the numbers treating them as arrays of 64-bit words
        const unsigned char a_words = a->top * 2; // Since each BN_ULONG is 128 bits (2 * 64 bits)
        const unsigned char b_words = b->top * 2;
        uint64_t a_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t b_array[MAX_BIGNUM_SIZE * 2] = {0};
        uint64_t result_array[MAX_BIGNUM_SIZE * 4] = {0};

        // Expand a into a_array
        for (unsigned char i = 0; i < a->top; ++i) {
            a_array[i * 2] = (uint64_t)(a->d[i]);
            a_array[i * 2 + 1] = (uint64_t)(a->d[i] >> 64);
        }

        // Expand b into b_array
        for (unsigned char i = 0; i < b->top; ++i) {
            b_array[i * 2] = (uint64_t)(b->d[i]);
            b_array[i * 2 + 1] = (uint64_t)(b->d[i] >> 64);
        }
        // char i = (char)max(a->top, b->top);
        // while (i > 0) {
        //     --i;
        //     if (i < a->top) {
        //         a_array[i * 2] = (uint64_t)(a->d[i]);
        //         a_array[i * 2 + 1] = (uint64_t)(a->d[i] >> 64);
        //     }
        //     if (i < b->top) {
        //         b_array[i * 2] = (uint64_t)(b->d[i]);
        //         b_array[i * 2 + 1] = (uint64_t)(b->d[i] >> 64);
        //     }
        // }

        unsigned __int128 temp;
        uint64_t carry;
        // Multiply the arrays
        for (unsigned char i = 0; i < a_words; ++i) {
            carry = 0;
            for (unsigned char j = 0; j < b_words; ++j) {
                // unsigned __int128 temp = (unsigned __int128)a_array[i] * b_array[j] + result_array[i + j] + carry;
                temp = (unsigned __int128)a_array[i] * b_array[j];
                temp += result_array[i + j];
                temp += carry;
                result_array[i + j] = (uint64_t)temp;
                carry = (uint64_t)(temp >> 64);
            }
            result_array[i + b_words] += carry;
        }

        // Convert result_array back into product->d
        unsigned char product_words = a_words + b_words;
        unsigned char product_top = (product_words + 1) / 2;
        for (unsigned char i = 0; i < product_top; ++i) {
            uint64_t lo = result_array[i * 2];
            uint64_t hi = result_array[i * 2 + 1];
            product->d[i] = ((unsigned __int128)hi << 64) | lo;
        }
        product->top = find_top_optimized(product, product_top);
        #ifdef debug_top
            if (product->top > MAX_BIGNUM_SIZE) {
                printf("### bn_mul ERROR: product->top > MAX_BIGNUM_SIZE\n");
            }
        #endif
    #else
        // Unroll loops if possible
        for (int i = 0; i < a->top; i++) {
            BN_ULONG carry = 0;
            for (int j = 0; j < b->top; j++) {
                unsigned __int128 temp = (unsigned __int128)a->d[i] * b->d[j] + product->d[i + j] + carry;
                product->d[i + j] = (BN_ULONG)temp;
                carry = (BN_ULONG)(temp >> 64);
            }
            product->d[i + b->top] = carry;
        }
        // Update the top
        product->top = a->top + b->top;
        while (product->top > 1 && product->d[product->top - 1] == 0) {
            product->top--;
        }
    #endif
    // Set the sign
    if (!absolute) product->neg = a->neg ^ b->neg;
    #ifdef debug_print
        bn_print("<< product: ", product);
        printf("-- bn_mul --\n");
    #endif
    #ifdef function_profiler
        record_function(FN_BN_MUL_FROM_DIV, start_time);
    #endif
    // bn_print_no_fuse("<< product: ", product);
}

__device__ int bn_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *n) {
    // r: Remainder (updated)
    // a: Dividend
    // n: Modulus
    bool debug = 0;
    if (debug) {
        printf("++ bn_mod ++\n");
        bn_print(">> r: ", r);
        bn_print(">> a: ", a);
        bn_print(">> n: ", n);
    }

    BIGNUM q;
    init_zero(&q);

    if (r == n) {
        printf("bn_mod: ERR_R_PASSED_INVALID_ARGUMENT");
        return 0;
    }
    if (!bn_div(&q, r, a, n)) {
        return 0;
    }

    BIGNUM tmp;
    init_zero(&tmp);

    if (r->neg) {
        if (debug) printf("r is negative\n");
        bool result;
        // If the remainder is negative, add the absolute value of the divisor
        if (n->neg) {
            if (debug) printf("d is negative\n");
            result = bn_sub(&tmp, r, n); // tmp = r - n
            if (!result) {
                return 0;
            }
            #ifdef debug_bn_copy
                printf("bn_mod: bn_copy(tmp, r)\n");
            #endif
            // copy tmp to r
            bn_copy(r, &tmp);
        } else {
            if (debug) printf("d is not negative\n");
            result = bn_add(&tmp, r, n); // tmp = r + n            
            if (!result) {
                return 0;
            }
            #ifdef debug_bn_copy
                printf("bn_mod: bn_copy(tmp, r)\n");
            #endif
            // copy tmp to r
            bn_copy(r, &tmp);
        }
    }
    if (debug) bn_print("<< r bn_mod: ", r);
    if (debug) printf("-- bn_mod --\n");
    return 1;
}

__device__ void mod_mul(BIGNUM *a, BIGNUM *b, BIGNUM *mod, BIGNUM *result) {
    debug_printf("mod_mul 0\n");
    BIGNUM product;
    init_zero(&product);
    debug_printf("mod_mul 1\n");
    // Now, you can call the bn_mul function and pass 'product' to it
    bn_mul(a, b, &product);
    debug_printf("mod_mul 2\n");
    
    
    bn_mod(&product, mod, result);

    debug_printf("mod_mul 3\n");
}

__device__ bool bn_is_zero(const BIGNUM *a) {
    #ifdef debug_top
        if (a->top != find_top(a)) printf("### ERROR: bn_is_zero: a->top (%d) != find_top(a) (%d)\n", a->top, find_top(a));
    #endif
    for (int i = 0; i < a->top; ++i) {
        if (a->d[i] != 0) {
            return false;
        }
    }
    return true;
}

__device__ bool bn_is_one(const BIGNUM *a) {
    // Assuming that BIGNUM stores the number in an array 'd' of integers
    // and 'top' indicates the number of chunks being used.
    // We also assume that 'd' is big-endian and 'top' is the index of the highest non-zero digit.
    
    // The number one would be represented with only the least significant digit being one
    // and all other digits being zero.
    if (a->top != 1) {  // If there are more than one digits in use, it cannot be one
        return false;
    }
    if (a->d[0] != 1) {  // The number one should only have the least significant digit set to one
        return false;
    }
    // Ensure that any other digits (if they exist in memory) are zero
    // This isn't strictly necessary if the 'top' index is always accurate
    // but is a good sanity check if there's any possibility of memory corruption or improper initialization.
    for (int i = 1; i < MAX_BIGNUM_SIZE; ++i) {
        if (a->d[i] != 0) {
            return false;
        }
    }
    return true;
}

__device__ void bn_set_word(BIGNUM *bn, BN_ULONG word) {
    // Assuming d is a pointer to an array where the BIGNUM's value is stored
    // and top is an integer representing the index of the most significant word + 1
    // Setting a BIGNUM to a single-word value means that all other words are zero.

    #ifdef debug_top
        if (bn->top != find_top(bn)) {
            if (bn->top != find_top(bn)) printf("### ERROR: bn_set_word: bn->top (%d) != find_top(bn) (%d)\n", bn->top, find_top(bn));
        }
    #endif

    // Clear all words in the BIGNUM
    for (int i = 0; i < MAX_BIGNUM_SIZE; ++i) {
        bn->d[i] = 0;
    }

    // Set the least significant word to the specified value
    bn->d[0] = word;

    // Update top to indicate that there's at least one significant digit
    bn->top = (word == 0) ? 0 : 1;

    // If using a sign flag, ensure the BIGNUM is set to non-negative
    if (bn->top) {
        bn->neg = 0;
    }
}

__device__ void left_shift(BIGNUM *a, int shift) {
    if (shift == 0) return;  // No shift needed

    int word_shift = shift / BN_ULONG_NUM_BITS;
    int bit_shift = shift % BN_ULONG_NUM_BITS;

    // Shift whole words
    if (word_shift > 0) {
        for (int i = MAX_BIGNUM_SIZE - 1; i >= word_shift; i--) {
            a->d[i] = a->d[i - word_shift];
        }
        for (int i = 0; i < word_shift; i++) {
            a->d[i] = 0;
        }
    }

    // Shift remaining bits
    if (bit_shift > 0) {
        BN_ULONG carry = 0;
        for (int i = 0; i < MAX_BIGNUM_SIZE; i++) {
            BN_ULONG new_carry = a->d[i] >> (BN_ULONG_NUM_BITS - bit_shift);
            a->d[i] = (a->d[i] << bit_shift) | carry;
            carry = new_carry;
        }
    }

    // Calculate new top
    unsigned char potential_new_top = a->top + (shift + BN_ULONG_NUM_BITS - 1) / BN_ULONG_NUM_BITS;
    a->top = find_top_optimized(a, potential_new_top);
}

__device__ int bn_div(BIGNUM *bn_quotient, BIGNUM *bn_remainder, const BIGNUM *bn_dividend, const BIGNUM *bn_divisor)
{
    #ifdef function_profiler
        unsigned long long start_time = clock64();
    #endif
    #ifdef debug_print
        // printf("++ bn_div ++\n");
        // bn_print(">> bn_dividend: ", bn_dividend);
        // bn_print(">> bn_divisor: ", bn_divisor);
    #endif
    unsigned char divs_max_top = max(bn_dividend->top, bn_divisor->top);
    
    // perform classical div_mod if only single word
    if (divs_max_top == 1) {
        BN_ULONG dividend = bn_dividend->d[0];
        BN_ULONG divisor = bn_divisor->d[0];
        BN_ULONG quotient = dividend / divisor;
        BN_ULONG remainder = dividend % divisor;
        bn_quotient->d[0] = quotient;
        bn_remainder->d[0] = remainder;
        bn_quotient->top = (quotient == 0) ? 0 : 1;
        bn_remainder->top = (remainder == 0) ? 0 : 1;
        bn_quotient->neg = bn_dividend->neg ^ bn_divisor->neg;
        bn_remainder->neg = bn_dividend->neg;
        #ifdef function_profiler
            record_function(FN_BN_DIV, start_time);
        #endif
        return 1;
    }
    BIGNUM abs_dividend;
    init_zero(&abs_dividend);
    // Copy absolute values
    for (int i = 0; i < bn_dividend->top; i++) {
        abs_dividend.d[i] = bn_dividend->d[i];
    }
    abs_dividend.top = bn_dividend->top;   

    // Store signs and work with absolute values
    abs_dividend.neg = 0;

    // Initialize quotient and remainder
    init_zero(bn_quotient);
    init_zero(bn_remainder);
    // Perform long division
    BIGNUM current_dividend;
    init_zero(&current_dividend);
    char dividend_size = abs_dividend.top;

    for (int i = dividend_size - 1; i >= 0; i--) {
        // Shift current_dividend left by one word and add next word of dividend
        left_shift(&current_dividend, BN_ULONG_NUM_BITS);
        current_dividend.d[0] = abs_dividend.d[i];
        // Find quotient digit
        BN_ULONG q = 0;
        BN_ULONG left = 0, right = BN_ULONG_MAX;
        // BN_ULONG prev_mid = 0;
        unsigned int j = 0;
        while (left <= right) {
            BN_ULONG mid = left + (right - left) / 2;
            BIGNUM temp, product;
            init_zero(&temp);
            init_zero(&product);
            temp.d[0] = mid;
            temp.top = 1;
            bn_mul_from_div(bn_divisor, &temp, &product, true);

            if (bn_cmp(&product, &current_dividend) <= 0) {
                q = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }            
        }

        // Add quotient digit to result
        left_shift(bn_quotient, BN_ULONG_NUM_BITS);
        bn_quotient->d[0] |= q;

        // Subtract q * divisor from current_dividend
        BIGNUM temp, product;
        init_zero(&temp);
        init_zero(&product);
        temp.d[0] = q;
        temp.top = 1;

        bn_mul_from_div(bn_divisor, &temp, &product, true);
        bn_sub_from_div(&current_dividend, &current_dividend, &product);
    }

    // Set remainder
    for (int i = 0; i < current_dividend.top; i++) {
        bn_remainder->d[i] = current_dividend.d[i];
    }

    // Apply correct signs
    bn_quotient->neg = bn_dividend->neg ^ bn_divisor->neg;
    bn_remainder->neg = bn_dividend->neg;

    // Normalize results
    bn_quotient->top = find_top_optimized(bn_quotient, divs_max_top);
    bn_remainder->top = find_top_optimized(bn_remainder, divs_max_top);
    #ifdef debug_print
        // bn_print("<< bn_quotient: ", bn_quotient);
        // bn_print("<< bn_remainder: ", bn_remainder);
        // printf("-- bn_div --\n");
    #endif
    #ifdef function_profiler
        record_function(FN_BN_DIV, start_time);
    #endif
    return 1;
}
```

# point.h
```
struct EC_POINT_CUDA {
  BIGNUM x; 
  BIGNUM y;
};

__device__ bool bn_mod_inverse(BIGNUM *result, const BIGNUM *a, const BIGNUM *n) {
    #ifdef debug_print
        printf("++ bn_mod_inverse ++\n");
        bn_print(">> a: ", a);
        bn_print(">> n: ", n);
    #endif
    
    if (bn_is_one(n)) {
        return false;  // No modular inverse exists
    }

    BIGNUM r;
    BIGNUM nr;
    BIGNUM t;
    BIGNUM nt;
    BIGNUM q;
    BIGNUM tmp;
    BIGNUM tmp2;
    BIGNUM tmp3;

    init_zero(&r);
    init_zero(&nr);
    init_zero(&t);
    init_one(&nt);
    init_zero(&q);
    init_zero(&tmp);
    init_zero(&tmp2);
    init_zero(&tmp3);
    #ifdef debug_bn_copy
        printf("bn_mod_inverse: bn_copy(r, n)\n");
    #endif
    bn_copy(&r, n);
    bn_mod(&nr, a, n); // Compute non-negative remainder of 'a' modulo 'n'
    #ifdef debug_print
        unsigned int counter = 0;
    #endif
    while (!bn_is_zero(&nr)) {
        bn_div(&q, &tmp, &r, &nr); // Compute quotient and remainder
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(tmp, nt)\n");
        #endif
        bn_copy(&tmp, &nt);
        bn_mul(&q, &nt, &tmp2); // tmp2 = q * nt
        init_zero(&tmp3);
        bn_sub(&tmp3, &t, &tmp2); // tmp3 = t - tmp2
        // if (tmp3.top!=find_top(&tmp3)) printf("*** hypotesis true: bn_sub top is not correct\n");
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(nt, tmp3)\n");
        #endif
        bn_copy(&nt, &tmp3); // dst << src
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(t, tmp)\n");
        #endif
        bn_copy(&t, &tmp);
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(tmp, nr)\n");
        #endif
        bn_copy(&tmp, &nr);
        bn_mul(&q, &nr, &tmp2);
        init_zero(&tmp3);
        bn_sub(&tmp3, &r, &tmp2); // tmp3 = r - tmp2
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(r, tmp3)\n");
        #endif
        bn_copy(&nr, &tmp3);
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(r, tmp)\n");
        #endif
        bn_copy(&r, &tmp);        
        #ifdef debug_print
            counter++;
            printf("[%d] ", counter);
            bn_print(" t: ", &t);
        #endif
    }

    if (!bn_is_one(&r)) {
        init_zero(result);
        return false; // No modular inverse exists
    }

    if (t.neg != 0) {
        bn_add(&tmp2, &t, n); // tmp2 = t + n
        #ifdef debug_bn_copy
            printf("bn_mod_inverse: bn_copy(t, tmp2)\n");
        #endif
        bn_copy(&t, &tmp2);
    }
    #ifdef debug_bn_copy
        printf("bn_mod_inverse: bn_copy(result, t)\n");
    #endif
    bn_copy(result, &t);
    #ifdef debug_print
        bn_print("<< result: ", result);
        printf("-- bn_mod_inverse --\n");
    #endif
    return true;
}

// limit to 256 bits
__device__ void bignum_to_bit_array(BIGNUM *n, unsigned int *bits) {
    #ifdef debug_print
        printf("++ bignum_to_bit_array ++\n");
        bn_print(">> n: ", n);
    #endif
    int index = 0;
    int total_bits = n->top * BN_ULONG_NUM_BITS;

    if (total_bits > MAX_BIT_ARRAY_SIZE) {
        total_bits = MAX_BIT_ARRAY_SIZE;
    }

    // Iterate through the words
    for (int i = 0; i < n->top && index < total_bits; ++i) {
        BN_ULONG word = n->d[i];
        for (int j = 0; j < BN_ULONG_NUM_BITS && index < total_bits; ++j) {
            bits[index++] = (word >> j) & 1;
        }
    }

    // Fill the remaining bits with zeros
    while (index < MAX_BIT_ARRAY_SIZE) {
        bits[index++] = 0;
    }
    #ifdef debug_print
        printf("<< bits (uint): ");
        for (int i = 0; i < MAX_BIT_ARRAY_SIZE; i++) {
            printf("%d", bits[i]);
        }
        printf("\n<< bits (hex): ");
        for (int i = 0; i < MAX_BIT_ARRAY_SIZE; i++) {
            printf("%x", bits[i]);
        }
        printf("-- bignum_to_bit_array --\n");
    #endif
}

// In the current structure, we might use a specific value (e.g., 0 or -1) 
// to represent the components of the point at infinity.
// A version that uses 0 to signify the point at infinity could be:
__device__ int point_is_at_infinity(const EC_POINT_CUDA *P) {    
    if (bn_is_zero(&P->x) || bn_is_zero(&P->y)) {
        return 1; // P is the point at infinity
    }
    return 0; // P is not the point at infinity
}

__device__ void copy_point(EC_POINT_CUDA *dest, EC_POINT_CUDA *src) {
    // Assuming EC_POINT_CUDA contains BIGNUM structures for x and y,
    // and that BIGNUM is a structure that contains an array of BN_ULONG for the digits,
    // along with other metadata (like size, top, neg, etc.)

    // init the dest point
    init_zero(&dest->x);
    init_zero(&dest->y);

    // Copy the BIGNUM x
    #ifdef debug_bn_copy
        printf("copy_point: bn_copy(dest->x, src->x)\n");
    #endif
    bn_copy(&dest->x, &src->x);

    // Copy the BIGNUM y
    #ifdef debug_bn_copy
        printf("copy_point: bn_copy(dest->y, src->y)\n");
    #endif
    bn_copy(&dest->y, &src->y);
}

__device__ void set_point_at_infinity(EC_POINT_CUDA *point) {
    // Assuming EC_POINT_CUDA is a structure containing BIGNUM x and y
    // and that a BIGNUM value of NULL or {0} represents the point at infinity

    // To set the point at infinity, one straightforward way is to assign
    // a null pointer to x and y if the BIGNUM structure allows it, or 
    // set their values to some predetermined sentinel value that indicates
    // the point at infinity.

    // If using the sentinel value approach - ensure BIGNUM is set in a way
    // that other functions can check for it and treat it as infinity

    // To set the point to 0 (as an example sentinel value), do:
    init_zero(&point->x);
    init_zero(&point->y);// Ensure that this logic matches how you identify point at infinity elsewhere
}

__device__ int point_add(
    EC_POINT_CUDA *result, 
    EC_POINT_CUDA *p1, 
    EC_POINT_CUDA *p2, 
    const BIGNUM *p, 
    const BIGNUM *a
) {
    bool debug = 0;
    if (debug) {
        printf("++ point_add ++\n");
        bn_print(">> p1.x: ", &p1->x);
        bn_print(">> p1.y: ", &p1->y);
        bn_print(">> p2.x: ", &p2->x);
        bn_print(">> p2.y: ", &p2->y);
        bn_print(">> p: ", p);
        bn_print(">> a: ", a);
    }
    // bn_print_no_fuse(">> p1.x: ", &p1->x);
    // bn_print_no_fuse(">> p1.y: ", &p1->y);
    // bn_print_no_fuse(">> p2.x: ", &p2->x);
    // bn_print_no_fuse(">> p2.y: ", &p2->y);
    // bn_print_no_fuse(">> p: ", p);
    // bn_print_no_fuse(">> a: ", a);
    debug = 0;
    // Handle the point at infinity cases
    if (point_is_at_infinity(p1)) {
        copy_point(result, p2);
        if (debug) printf("p1 point at infinity\n");
        return 0;
    }

    if (point_is_at_infinity(p2)) {
        copy_point(result, p1);
        if (debug) printf("p2 point at infinity\n");
        return 0;
    }

    // Initialize temporary BIGNUMs for calculation
    BIGNUM s, x3, y3, tmp1, tmp2, tmp3, two, tmp1_squared;
    init_zero(&s);
    init_zero(&x3);
    init_zero(&y3);
    init_zero(&tmp1);
    init_zero(&tmp2);
    init_zero(&tmp3);
    init_zero(&two);
    init_zero(&tmp1_squared);

    // Case 1: p1 = p2 && p1.y != p2.y
    if (bn_cmp(&p1->x, &p2->x) == 0 && bn_cmp(&p1->y, &p2->y) != 0) {
        // The points are inverses to one another, return point at infinity
        if (debug) printf("The points are inverses to one another\n");
        set_point_at_infinity(result);
        return 0;
    }

    

    // Case 3: p1 == p2
    if (bn_cmp(&p1->x, &p2->x) == 0) {
        // Point doubling
        init_zero(&two);
        bn_set_word(&two, 2);

        // BIGNUM tmp1_squared;
        init_zero(&tmp1_squared);
        init_zero(&tmp1);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp1, p1->x)\n");
        #endif
        bn_copy(&tmp1, &p1->x); // dst << src
        if (debug) {
            bn_print("\n[0] >> bn_mul p1.x: ", &p1->x);
            bn_print("[0] >> bn_mul tmp1: ", &tmp1);
        }
        bn_mul(&p1->x, &tmp1, &tmp1_squared);     // tmp1_squared = p1.x^2 // a * b = product
        if (debug) {
            bn_print("[0] << bn_mul tmp1: ", &tmp1_squared);
        }

        init_zero(&tmp1);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp1, tmp1_squared)\n");
        #endif
        bn_copy(&tmp1, &tmp1_squared); // dst << src
        // Init tmp2 as 3
        init_zero(&tmp2);
        bn_set_word(&tmp2, 3);
        bn_mul(&tmp1, &tmp2, &tmp1_squared);     // a * b = product
        if (debug) bn_print("\n[1] << bn_mul tmp1_squared: ", &tmp1_squared); // OK

        if (debug) bn_print("\n[2] << bn_add tmp1_squared: ", &tmp1_squared); // 

        init_zero(&tmp1);
        if (debug) bn_print("\n# [3] >> bn_mod tmp1_squared: ", &tmp1_squared);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp1, tmp1_squared)\n");
        #endif
        bn_copy(&tmp1, &tmp1_squared); // dst << src        
        if (debug) bn_print("# [3] >> bn_mod tmp1: ", &tmp1);
        init_zero(&tmp1_squared);
        if (debug) bn_print("[3] >> bn_mod tmp1_squared: ", &tmp1_squared);
        if (debug) bn_print("[3] >> bn_mod tmp1: ", &tmp1);
        if (debug) bn_print("[3] >> bn_mod p: ", p);
        bn_mod(&tmp1_squared, &tmp1, p);           // tmp1_squared = tmp1 mod p
        if (debug) bn_print("[3] << bn_mod tmp1_squared: ", &tmp1_squared); // OK
        if (debug) bn_print("[3] << bn_mod tmp1: ", &tmp1);
        
        init_zero(&tmp2);
        bn_set_word(&two, 2);
        bn_mul(&p1->y, &two, &tmp2);  // tmp2 = 2 * p1.y
        if (debug) bn_print("\n[4] << bn_mul tmp2: ", &tmp2); // OK

        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp2)\n");
        #endif
        bn_copy(&tmp3, &tmp2); // dst << src
        bn_mod(&tmp2, &tmp3, p);           // tmp2 = tmp3 mod p
        if (debug) bn_print("\n[5] << bn_mod tmp2: ", &tmp2); // OK
        
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp2)\n");
        #endif
        bn_copy(&tmp3, &tmp2); // dst << src
        init_zero(&tmp2);
        if (debug) bn_print("\n[6] >> bn_mod_inverse tmp2: ", &tmp2);
        if (debug) bn_print("[6] >> bn_mod_inverse tmp3: ", &tmp3);
        if (debug) bn_print("[6] >> bn_mod_inverse p: ", p);
        bn_mod_inverse(&tmp2, &tmp3, p);  // tmp2 = tmp3 mod p
        if (debug) bn_print("[6] << bn_mod_inverse tmp2: ", &tmp2); // 
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp1_squared)\n");
        #endif
        bn_copy(&tmp3, &tmp1_squared); // dst << src
        if (debug) bn_print("\n[7] >> bn_mul tmp3: ", &tmp3);
        if (debug) bn_print("[7] >> bn_mul tmp2: ", &tmp2);
        bn_mul(&tmp3, &tmp2, &s);  // tmp1 * tmp2 = s
        if (debug) bn_print("[7] << bn_mul s: ", &s); //

        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, s)\n");
        #endif
        bn_copy(&tmp3, &s); // dst << src
        bn_mod(&s, &tmp3, p);  // s = s mod p
        if (debug) bn_print("\n[8] << bn_mod s: ", &s); //

        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, s)\n");
        #endif
        bn_copy(&tmp3, &s); // dst << src
        bn_mul(&tmp3, &tmp3, &x3);  // x3 = s^2
        bn_sub(&x3, &x3, &p1->x);  // x3 = x3 - p1.x
        bn_sub(&x3, &x3, &p1->x);  // x3 = x3 - p1.x
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, x3)\n");
        #endif
        bn_copy(&tmp3, &x3); // dst << src
        bn_mod(&x3, &tmp3, p);  // x3 = x3 mod p
        init_zero(&tmp1);
        bn_sub(&tmp1, &p1->x, &x3);  // tmp1 = p1.x - x3
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, s)\n");
        #endif
        bn_copy(&tmp3, &s); // dst << src
        bn_mul(&tmp3, &tmp1, &y3);  // y3 = s * tmp1
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, y3)\n");
        #endif
        bn_copy(&tmp3, &y3); // dst << src
        bn_sub(&y3, &tmp3, &p1->y);  // y3 = y3 - p1.y
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, y3)\n");
        #endif
        bn_copy(&tmp3, &y3); // dst << src
        bn_mod(&y3, &tmp3, p);  // y3 = y3 mod p
    } else {
        // Case 2: p1 != p2
        if (debug) printf("p1 != p2\n");
        // Regular point addition
        bn_sub(&tmp1, &p2->y, &p1->y);
        if (debug) printf("# 0\n");
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp1)\n");
        #endif
        bn_copy(&tmp3, &tmp1); // dst << src
        if (debug) printf("# 1\n");
        init_zero(&tmp1);
        bn_mod(&tmp1, &tmp3, p);           // tmp1 = (p2.y - p1.y) mod p 
        if (debug) printf("# 2\n");
        init_zero(&tmp2);
        bn_sub(&tmp2, &p2->x, &p1->x);
        if (debug) printf("# 3\n");
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp2)\n");
        #endif
        bn_copy(&tmp3, &tmp2);
        if (debug) printf("# 4\n");
        bn_mod(&tmp2, &tmp3, p);           // tmp2 = (p2.x - p1.x) mod p
        if (debug) printf("# 5\n");
        init_zero(&tmp3);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp3, tmp2)\n");
        #endif
        bn_copy(&tmp3, &tmp2);
        if (debug) printf("# 6\n");
        init_zero(&tmp2);
        bn_mod_inverse(&tmp2, &tmp3, p); // OK
        if (debug) printf("# 7\n");
        init_zero(&s);
        bn_mul(&tmp1, &tmp2, &s);
        bn_print("### s:", &s); // Debug OK
        if (debug) printf("# 8\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, s)\n");
        #endif
        bn_copy(&tmp2, &s);
        if (debug) printf("# 9\n"); // tmp2 OK
        init_zero(&s);
        bn_mod(&s, &tmp2, p);                 // s = (p2.y - p1.y) / (p2.x - p1.x) mod p
        if (debug) printf("# 10\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, s)\n");
        #endif
        bn_copy(&tmp2, &s);
        if (debug) printf("# 11\n");
        bn_mul(&s, &tmp2, &x3); // a * b = product // x3 = s^2
        if (debug) printf("# 12\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, x3)\n");
        #endif
        bn_copy(&tmp2, &x3);
        if (debug) printf("# 13\n");
        bn_sub(&x3, &tmp2, &p1->x); // result = a - b
        if (debug) printf("# 14\n");
        bn_sub(&x3, &x3, &p2->x);          // x3 = s^2 - p1.x - p2.x
        if (debug) printf("# 15\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, x3)\n");
        #endif
        bn_copy(&tmp2, &x3);
        if (debug) printf("# 16\n");
        bn_mod(&x3, &tmp2, p); // x3 = tmp2 mod p // OK
        if (debug) printf("# 17\n");
        bn_sub(&tmp1, &p1->x, &x3);
        if (debug) printf("# 18\n");
        bn_mul(&s, &tmp1, &y3); // a * b = product
        if (debug) printf("# 19\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, y3)\n");
        #endif
        bn_copy(&tmp2, &y3);
        if (debug) printf("# 20\n");
        bn_sub(&y3, &tmp2, &p1->y);          // y3 = s * (p1.x - x3) - p1.y
        if (debug) printf("# 21\n");
        init_zero(&tmp2);
        #ifdef debug_bn_copy
            printf("point_add: bn_copy(tmp2, y3)\n");
        #endif
        bn_copy(&tmp2, &y3);
        if (debug) printf("# 22\n");
        bn_mod(&y3, &tmp2, p);               // y3 = tmp2 mod p
        if (debug) printf("# 23\n");
    }

    if (debug) {
        printf("copy result to x3\n");
    }
    // Assign the computed coordinates to the result
    #ifdef debug_bn_copy
        printf("point_add: bn_copy(result->x, x3)\n");
    #endif
    bn_copy(&result->x, &x3);
    #ifdef debug_bn_copy
        printf("point_add: bn_copy(result->y, y3)\n");
    #endif
    bn_copy(&result->y, &y3);
    debug = 1;
    if (debug) {
        bn_print("<< x3: ", &x3);
        bn_print("<< y3: ", &y3);
    }

    // Free the dynamically allocated memory
    // free_bignum(&s);
    // free_bignum(&x3);
    // free_bignum(&y3);
    // free_bignum(&tmp1);
    // free_bignum(&tmp2);
    // free_bignum(&tmp3);
    // free_bignum(&two);
    // free_bignum(&tmp1_squared);

    return 0;
}

__device__ void init_point_at_infinity(EC_POINT_CUDA *P) {
    // For the x and y coordinates of P, we'll set the 'top' to 0,
    // which is our chosen convention for representing the point at infinity.

    init_zero(&P->x);
    init_zero(&P->y);

    P->x.top = 1; // No valid 'words' in the BIGNUM representing x
    P->y.top = 1; // No valid 'words' in the BIGNUM representing y
    
    // If 'd' arrays have been allocated, set them to zero as well.
    // memset could potentially be used for this if available and if 'd' is allocated.
    // Alternatively, if you use flags or other conventions for points at infinity,
    // set them accordingly here.
}

__device__ EC_POINT_CUDA ec_point_scalar_mul(
    EC_POINT_CUDA *point, 
    BIGNUM *scalar, 
    BIGNUM *curve_prime, 
    BIGNUM *curve_a
    ) {
    bool debug = 0;
    if (debug) {
        debug_printf("++ ec_point_scalar_mul ++\n");
        bn_print(">> point x: ", &point->x);
        bn_print(">> point y: ", &point->y);
        bn_print(">> scalar: ", scalar);
        bn_print(">> curve_prime: ", curve_prime);
        bn_print(">> curve_a: ", curve_a);
    }
    
    EC_POINT_CUDA current = *point; // This initializes the current point with the input point
    EC_POINT_CUDA result; // Initialize the result variable, which accumulates the result
    EC_POINT_CUDA tmp_result;
    EC_POINT_CUDA tmp_a;
    EC_POINT_CUDA tmp_b;                                     
    
    init_point_at_infinity(&result);                 // Initialize it to the point at infinity
    init_point_at_infinity(&tmp_result);                 // Initialize it to the point at infinity
    init_point_at_infinity(&tmp_a);                 // Initialize it to the point at infinity
    init_point_at_infinity(&tmp_b);                 // Initialize it to the point at infinity
    
    // Convert scalar BIGNUM to an array of integers that's easy to iterate bit-wise
    unsigned int bits[256];                          // Assuming a 256-bit scalar
    bignum_to_bit_array(scalar, bits);    
    if (debug) printf("[D] Starting scalar multiplication loop\n");
    for (int i = 0; i < 256; i++) {                 // Assuming 256-bit scalars        
        if (debug) printf("[%d] step 0\n", i);
        if (bits[i]) {// If the i-th bit is set
            if (debug) printf("[%d] step 1\n", i);
            init_point_at_infinity(&tmp_result);
            if (debug) printf("[%d] step 2\n", i);
            point_add(&tmp_result, &result, &current, curve_prime, curve_a);  // Add current to the result
            if (debug) printf("[%d] step 3\n", i);
            init_point_at_infinity(&result); // Reset result
            if (debug) printf("[%d] step 4\n", i);
            #ifdef debug_bn_copy
                printf("ec_point_scalar_mul: bn_copy(result.x, tmp_result.x)\n");
            #endif
            bn_copy(&result.x, &tmp_result.x);
            if (debug) printf("[%d] step 5\n", i);
            #ifdef debug_bn_copy
                printf("ec_point_scalar_mul: bn_copy(result.y, tmp_result.y)\n");
            #endif
            bn_copy(&result.y, &tmp_result.y);            
        }
        if (debug) printf("[%d] step 6\n", i);
        // init tmp_result
        init_point_at_infinity(&tmp_result);
        if (debug) printf("[%d] step 7\n", i);
        // init tmp_a
        init_point_at_infinity(&tmp_a);
        if (debug) printf("[%d] step 8\n", i);
        // init tmp_b
        init_point_at_infinity(&tmp_b);
        if (debug) printf("[%d] step 9\n", i);
        // Copy current to tmp_a
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(tmp_a.x, current.x)\n");
        #endif
        bn_copy(&tmp_a.x, &current.x);
        if (debug) printf("[%d] step 10\n", i);
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(tmp_a.y, current.y)\n");
        #endif
        bn_copy(&tmp_a.y, &current.y);
        if (debug) printf("[%d] step 11\n", i);
        // Copy current to tmp_b
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(tmp_b.x, current.x)\n");
        #endif
        bn_copy(&tmp_b.x, &current.x);
        if (debug) printf("[%d] step 12\n", i);
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(tmp_b.y, current.y)\n");
        #endif
        bn_copy(&tmp_b.y, &current.y);
        if (debug) printf("[%d] step 13\n", i);
        point_add(&tmp_result, &tmp_a, &tmp_b, curve_prime, curve_a);  // Double current by adding to itself
        if (debug) printf("[%d] step 14\n", i);
        // Copy tmp_result to current
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(current.x, tmp_result.x)\n");
        #endif
        bn_copy(&current.x, &tmp_result.x);
        if (debug) printf("[%d] step 15\n", i);
        #ifdef debug_bn_copy
            printf("ec_point_scalar_mul: bn_copy(current.y, tmp_result.y)\n");
        #endif
        bn_copy(&current.y, &tmp_result.y);
        if (debug) printf("[%d] passed\n", i);
    }    
    // Copy current to result
    if (debug) bn_print("3 result.x: ", &result.x);
    if (debug) bn_print("3 result.y: ", &result.y);
    return result;
}
```

# main.cu
```
#include <stdio.h>
#include <stdlib.h>
#include <cuda_runtime.h>

// Include your CUDA header files here
#include "bignum.h"
#include "point.h"
#include "public_key.h"

#define MAX_LINE_LENGTH 1024
#define MAX_TEST_CASES 1000
#define HEX_STRING_LENGTH 65  // 64 characters for 256-bit number + null terminator

// Structure to hold a test case
typedef struct {
    char Px[HEX_STRING_LENGTH], Py[HEX_STRING_LENGTH], Qx[HEX_STRING_LENGTH], Qy[HEX_STRING_LENGTH];
    char ExpectedAddX[HEX_STRING_LENGTH], ExpectedAddY[HEX_STRING_LENGTH];
    char ExpectedDoubleX[HEX_STRING_LENGTH], ExpectedDoubleY[HEX_STRING_LENGTH];
} TestCase;

// Device function to calculate string length
__device__ int d_strlen(const char *str) {
    int len = 0;
    while (str[len] != '\0') {
        len++;
    }
    return len;
}

// Device function to copy n characters from src to dest
__device__ char* d_strncpy(char *dest, const char *src, int n) {
    int i;
    for (i = 0; i < n && src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
    for (; i < n; i++) {
        dest[i] = '\0';
    }
    return dest;
}

// Device function to convert hex string to unsigned long long
__device__ unsigned long long d_strtoull(const char *str, char **endptr, int base) {
    unsigned long long result = 0;
    int i = 0;

    while (str[i] != '\0') {
        int digit;
        if (str[i] >= '0' && str[i] <= '9') {
            digit = str[i] - '0';
        } else if (str[i] >= 'a' && str[i] <= 'f') {
            digit = str[i] - 'a' + 10;
        } else if (str[i] >= 'A' && str[i] <= 'F') {
            digit = str[i] - 'A' + 10;
        } else {
            break;
        }
        
        if (digit >= base) {
            break;
        }
        
        result = result * base + digit;
        i++;
    }

    if (endptr) {
        *endptr = (char*)str + i;
    }

    return result;
}

// Function to initialize a BIGNUM from a hex string
__device__ void initBignumFromHex(BIGNUM *bn, const char *hex) {
    init_zero(bn);
    int len = d_strlen(hex);
    int word_index = 0;

    for (int i = len; i > 0; i -= 16) {
        char chunk[17] = {0};
        int chunk_len = (i < 16) ? i : 16;
        d_strncpy(chunk, hex + i - chunk_len, chunk_len);
        BN_ULONG word = d_strtoull(chunk, NULL, 16);
        bn->d[word_index++] = word;
    }

    bn->top = find_top(bn);
}

// CUDA kernel to perform the tests
__global__ void testEllipticCurve(TestCase *cases, int numCases, ThreadFunctionProfile *d_threadFunctionProfiles_param) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx >= numCases) return;

    #ifdef function_profiler
        unsigned long long start_time = clock64();
        d_threadFunctionProfiles = d_threadFunctionProfiles_param;
    #endif

    TestCase *tc = &cases[idx];
    EC_POINT_CUDA P, Q, resultAdd, resultDouble;

    // Initialize points P and Q
    initBignumFromHex(&P.x, tc->Px);
    initBignumFromHex(&P.y, tc->Py);
    initBignumFromHex(&Q.x, tc->Qx);
    initBignumFromHex(&Q.y, tc->Qy);

    // Perform point addition
    const BIGNUM CURVE_A_LOCAL = {0};
    const BIGNUM CURVE_P_LOCAL = {
        {
            0xFFFFFFFEFFFFFC2F,
            0xFFFFFFFFFFFFFFFF,
            0xFFFFFFFFFFFFFFFF,
            0xFFFFFFFFFFFFFFFF
        },
        CURVE_P_VALUES_MAX_SIZE,
        false
    };

    point_add(&resultAdd, &P, &Q, &CURVE_P_LOCAL, &CURVE_A_LOCAL);
    // Perform point doubling
    point_add(&resultDouble, &P, &P, &CURVE_P_LOCAL, &CURVE_A_LOCAL);
    // Initialize expected results
    BIGNUM expectedAddX, expectedAddY, expectedDoubleX, expectedDoubleY;
    initBignumFromHex(&expectedAddX, tc->ExpectedAddX);
    initBignumFromHex(&expectedAddY, tc->ExpectedAddY);
    initBignumFromHex(&expectedDoubleX, tc->ExpectedDoubleX);
    initBignumFromHex(&expectedDoubleY, tc->ExpectedDoubleY);

    // Compare results
    bool additionCorrect = (bn_cmp(&resultAdd.x, &expectedAddX) == 0) &&
                           (bn_cmp(&resultAdd.y, &expectedAddY) == 0);
    bool doublingCorrect = (bn_cmp(&resultDouble.x, &expectedDoubleX) == 0) &&
                           (bn_cmp(&resultDouble.y, &expectedDoubleY) == 0);

    // Print results
    printf("Test case %d: Addition %s, Doubling %s\n", idx,
           additionCorrect ? "PASS" : "FAIL",
           doublingCorrect ? "PASS" : "FAIL");
    #ifdef function_profiler
        record_function(FN_MAIN, start_time);
    #endif
}

// Host function to read test cases from file
int readTestCases(const char *filename, TestCase *cases) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        perror("Error opening file");
        return -1;
    }

    char line[MAX_LINE_LENGTH];
    int numCases = 0;

    while (fgets(line, sizeof(line), file) && numCases < MAX_TEST_CASES) {
        TestCase *tc = &cases[numCases];
        sscanf(line, "%64s %64s %64s %64s %64s %64s %64s %64s",
               tc->Px, tc->Py, tc->Qx, tc->Qy,
               tc->ExpectedAddX, tc->ExpectedAddY,
               tc->ExpectedDoubleX, tc->ExpectedDoubleY);
        numCases++;
    }

    fclose(file);
    return numCases;
}

int main() {
    TestCase *h_cases, *d_cases;
    int numCases;

    // Read test cases from file
    h_cases = (TestCase*)malloc(MAX_TEST_CASES * sizeof(TestCase));
    numCases = readTestCases("point_add_cases_full.txt", h_cases);
    if (numCases < 0) {
        fprintf(stderr, "Failed to read test cases\n");
        return 1;
    }

    // Allocate memory on device
    cudaMalloc(&d_cases, numCases * sizeof(TestCase));

    // Copy data to device
    cudaMemcpy(d_cases, h_cases, numCases * sizeof(TestCase), cudaMemcpyHostToDevice);

    // Launch kernel
    // int threadsPerBlock = 256;
    int threadsPerBlock = 1;
    int blocksPerGrid = (numCases + threadsPerBlock - 1) / threadsPerBlock;

    // Function profiling
    int totalThreads = blocksPerGrid * threadsPerBlock;
    // Allocate per-thread function profiling data
    ThreadFunctionProfile *h_threadFunctionProfiles = new ThreadFunctionProfile[totalThreads];
    ThreadFunctionProfile *d_threadFunctionProfiles;
    cudaMalloc(&d_threadFunctionProfiles, totalThreads * sizeof(ThreadFunctionProfile));
    cudaMemset(d_threadFunctionProfiles, 0, totalThreads * sizeof(ThreadFunctionProfile));

    printf("Launching kernel with %d blocks of %d threads\n", blocksPerGrid, threadsPerBlock);
    testEllipticCurve<<<blocksPerGrid, threadsPerBlock>>>(d_cases, numCases, d_threadFunctionProfiles);

    // Wait for GPU to finish
    cudaDeviceSynchronize();

    printf("Done\n");

    #ifdef function_profiler
        // After kernel execution, copy profiling data back to host
        cudaMemcpy(h_threadFunctionProfiles, d_threadFunctionProfiles, totalThreads * sizeof(ThreadFunctionProfile), cudaMemcpyDeviceToHost);
        // After kernel execution and copying profiling data back to host
        write_function_profile_to_csv("../../performance/functions_data/profile.csv", h_threadFunctionProfiles, totalThreads, threadsPerBlock);
    #endif
    // Clean up
    delete[] h_threadFunctionProfiles;
    cudaFree(d_threadFunctionProfiles);

    // Free device memory
    cudaFree(d_cases);

    // Free host memory
    free(h_cases);

    return 0;
}
```

## Affine bignum output:
```
Launching kernel with 10 blocks of 1 threads
Test case 9: Addition PASS, Doubling PASS
Test case 7: Addition PASS, Doubling PASS
Test case 0: Addition PASS, Doubling PASS
Test case 8: Addition PASS, Doubling PASS
Test case 2: Addition PASS, Doubling PASS
Test case 5: Addition PASS, Doubling PASS
Test case 4: Addition PASS, Doubling PASS
Test case 6: Addition PASS, Doubling PASS
Test case 1: Addition PASS, Doubling PASS
Test case 3: Addition PASS, Doubling PASS
Done
```

## Task
Need to implement Jacobian bignum approach. We may need to convert affine to jacobian and vice versa.